# RetroTurbo解调算法

## 1. 现象和波形描述

我们发现DSM和PAM结合时能够进一步提升速度，中间有一个optimal的选择。比如4阶DSM+2路偏振+16AM的情况是最佳组合，那么如何把信息解调出来？（PQAM类似QAM，每一路偏振方向是16AM，即有16个可能的取值，两路一共是16×16=256个点，也就是256QAM）

比如我们有128个bit，即16个byte的数据，首先把他们分为2路偏振，每路8byte，表示如下

```c
ABCDEFGH
abcdefgh
--发送的时间方向-->
```

然后把他们分为16AM发送（16AM的实现是用一个LCD上面有8:4:2:1比例的面积块，其可以产生强度为0~15的所有整数值。在这种情况下。），即没路偏振上每个symbol有4bit信息，用`A[4]`代表byte A的高4bit，用`A[0]`代表它的低4bit，那么细化的时间发送序列如下

```c
A[4] A[0] B[4] B[0] C[4] C[0] D[4] D[0] E[4] E[0] F[4] F[0] G[4] G[0] H[4] H[0]
a[4] a[0] b[4] b[0] c[4] c[0] d[4] d[0] e[4] e[0] f[4] f[0] g[4] g[0] h[4] h[0]
--发送的时间方向-->
```

4阶DSM意味着每时每刻有4个LCD在互相重叠，时间上可以如下表示（其中数字代表LCD的编号，不同数字是不同的LCD，句号点表示该LCD正在恢复中，不能继续发送信息，此时别的LCD可以发送信息）

```c
A[4] A[0] B[4] B[0] C[4] C[0] D[4] D[0] E[4] E[0] F[4] F[0] G[4] G[0] H[4] H[0]
11111...............11111...............11111...............11111..............
     22222...............22222...............22222...............22222..............
          33333...............33333...............33333...............33333..............
               44444...............44444...............44444...............44444.........
```

我们已经测量的LCD的曲线是：

快沿：`{0, 0.03f+0.05if, 0.07f+0.15if, 0.26f+0.2if, 0.55f+0.15if, 0.81f+0.09if, 0.93f+0.04if, 0.98f+0.01if, 1}`

慢沿：`{0, 0.01f-0.05if, 0.04f-0.13if, 0.10f-0.2if, 0.24f-0.3if, 0.49f-0.31if, 0.64f-0.33if, 0.74f-0.3if, 0.82f-0.28if, 0.86f-0.24if, 0.9f-0.2if, 0.94f-0.18if, 0.96f-0.15if, 0.965f-0.13if, 0.97f-0.1if, 0.98f-0.075if, 0.99f-0.05if, 0.995f-0.03if, 1.0f-0.01if, 1.0f-0.005if, 1}`

其中上升沿时间长度为1ms（上述序列总共持续的时间），下降沿时间长度为8ms。你可以自由调整这个时间，进行简单的线性插值，获得一个与实际波形相仿的simulation波形。

## 2. 算法设计需求

#### 最终目标：解码出每个bit是0还是1

我们已经有的一些思路，可以参考，但不做限制：

1. 需要对每个时间片计算出高阶调制的256QAM，到底是哪一个symbol（我们系统的复杂性在于PQAM的两路之间是有相互干扰的，而且干扰非常可观，如何去消除干扰？容易想到的一个方法是，既然最终波形是$a\times f_1(t)+b\times f_2(t)=F(t)$，其中$F(t)$是实际接收到的波形，$f_1(t)$和$f_2(t)$分别是两路偏振方向在接收端造成的影响，其波形数值在上一节中提到，而$a $和$b$则是待求的、取值为0~15的值。由于噪声的存在，不可能求解出$a $和$b$使得等式对所有$t$成立，那么容易想到的一个优化目标是：$\min\limits_{a,b}\sum\limits_{t=t_1}^{t_2}(F(t)-af_1(t)-bf_2(t))^2$。一个比较暴力的解决方法是，既然$a$和$b$都是离散取值，比如对于256QAM而言，$a$和$b$分别只能取0~15的整数，那么每个试一次就好了，但无疑这是极其低效的，这里需要优化）
2. 用上面的方法能够判断出来第一个symbol是什么，但想象一下，一旦因为噪声，某时刻有一个symbol解错了，那么错误会一直蔓延，后面很难恢复出来。那么一个暴力的想法是，我们要找全局最优解，其计算量对于上面的例子来说就是$2^{128}$，完全不可接受。之前的一个方案是剪枝，当我们发现如果某一个解的错误超过了一定阈值，那么判定扔掉它，因为即使计算完它，也不可能是最优解。

