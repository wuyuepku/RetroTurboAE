// use static here, simply test it and used later with demodulator
#define STATIC_EMULATOR_FOR_EASIER_COPY
#include "emulator_mseq.h"
#define MONGODAT_IMPLEMENTATION
#include "mongodat.h"
#include "sysutil.h"
#include <regex>
#include <random>
#include <cmath>
using namespace std;

const char *MONGO_URL, *MONGO_DATABASE;
MongoDat mongodat;
FastDSM_Encoder encoder;

#define cspeed 3e8
#define f 455000
double const_dist = 500.0;

struct Point
{
    double x, y, z;
};

// calculate the light amplitude at the Point p
// given the flashlight at (0,0,0), the fov angle fov
// coordinate axis: y up, x inside, z right
double get_amp(Point p, double fov)
{
    if (p.x < 0)    return 0;
    double yz = sqrt(p.z*p.z + p.y*p.y);
    double r = p.x * tan(M_PI*fov/360);
    if (r < yz) {
        printf("out of light range: (%lf, %lf, %lf)\n", p.x, p.y, p.z);
        return 0;
    }
    double dist2 = p.x*p.x + p.y*p.y + p.z*p.z;
    double amplitude = const_dist/(dist2 * dist2);
    return amplitude;
}

// calculate the cosine demodulation
double get_cos(Point p)
{
    double dist = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);
    double angle = 2*M_PI*f*dist/cspeed;
    // printf("cosine angle = %lf, cosine value = %lf\n", angle, cos(angle));
    return cos(angle);
}

// calculate the sine demodulation
double get_sin(Point p)
{
    double dist = sqrt(p.x*p.x + p.y*p.y + p.z*p.z);
    double angle = 2*M_PI*f*dist/cspeed;
    // printf("sine angle = %lf, sine value = %lf\n", angle, sin(angle));
    return sin(angle);
}

int main(int argc, char** argv) {
	HANDLE_DATA_BASIC_ARG_MODIFY_ARGC_ARGV(argc, argv, &MONGO_URL, &MONGO_DATABASE);

	MongoDat::LibInit();
	mongodat.open(MONGO_URL, MONGO_DATABASE);

    if (argc != 3 && argc != 4) {
        printf("usage: <collection> <id(12 byte hex = 24 char)> [EQUAL_LEN:0]\n");
        printf("  if EQUAL_LEN is applied, then the output data will be no less than that. this is useful when comparing with real-world data\n");
        printf("\n");
        printf("the database document should have the following fields:\n");
        printf("  refs_file: filename, e.g. ref17mseq8kSs.9v.bin or ref17mseq8kSs.5.5v.bin\n");
        printf("             you can download them from https://github.com/wuyuepku/RetroTurbo/releases/tag/LCDmodel\n");
        printf("             use `ref17mseq8kSs.9v.bin` or `ref17mseq8kSs.5.5v.bin`\n");
        printf("  M_reader: the number of readers(actually is sensor groups on one reader)\n");
        printf("  N_tag: the number of tags\n");
        printf("  S_location: the number of different locations\n");
        printf("  frequency: frequency of the tag sequences, which should be a factor of 80000\n");
        printf("  NLCDs: array of N integers, each is the NLCD of a tag\n");
        printf("  sequences: N sequence of modulated data (possibly generated by FastDSM_Modulate)\n");
        printf("  fov: the field of view angle of the flashlight\n");
        printf("  tag_location: moving coordinates, N*S array, each tag moves along the S points\n");
        printf("      each value is a three-element double tuple\n");
        printf("  tag_change_time: the time when tags change location, measured in symbols, array of S integers\n");
        printf("  const_dist: used to adjust the amplitude\n");
        printf("  noise: [optional] given by standard deviation, Guassian distribution\n");
        printf("the results will be stored in a vector `emulated_ids`, in which each string refers to a data that could be plotted in WebGUI\n");
        printf("\n");
        return -1;
    }

	const char* collection_str = argv[1];
	const char* record_id_str = argv[2];
	BsonOp record = mongodat.get_bsonop(collection_str, record_id_str);
    bool EQUAL_LEN = argc > 3 ? atoi(argv[3]) : 0;

	printf("reading parameters from database record [%s:%s]\n", collection_str, record_id_str);
    
    // frequency
    assert(record["frequency"].existed() && record["frequency"].type() == BSON_TYPE_DOUBLE);
    double frequency = record["frequency"].value<double>(); printf("frequency: %f\n", frequency);
    
    // read reference file
    assert(record["refs_file"].existed() && record["refs_file"].type() == BSON_TYPE_UTF8);
    string refs_file = record["refs_file"].value<string>(); printf("refs_file: %s\n", refs_file.c_str());
    ifstream file(refs_file.c_str(), std::ios::binary);
    assert(file && "reference file not exists");
    file.unsetf(std::ios::skipws);  // Stop eating new lines in binary mode!!!
    file.seekg(0, std::ios::end);
    streampos fileSize = file.tellg();
    assert(fileSize == (1 << 17) * 40 * sizeof(complex<float>) && "file size error");
    file.seekg(0, std::ios::beg);
    vector< complex<float> > vec; vec.resize((1 << 17) * 40);
    file.read((char*)vec.data(), fileSize);
    MS_Emulator_Single::set_ref(17, 2000, 80000, frequency, vec);

    // M_reader, N_tag and S_location
    assert(record["M_reader"].existed() && record["M_reader"].type() == BSON_TYPE_INT32);
    int M_reader = record["M_reader"].value<int32_t>(); printf("M_reader: %d\t", M_reader);
    assert(record["N_tag"].existed() && record["N_tag"].type() == BSON_TYPE_INT32);
    int N_tag = record["N_tag"].value<int32_t>(); printf("N_tag: %d\t", N_tag);
    assert(record["S_location"].existed() && record["S_location"].type() == BSON_TYPE_INT32);
    int S_location = record["S_location"].value<int32_t>(); printf("S_location: %d\n", S_location);

    // NLCDs
    assert(record["NLCDs"].existed() && record["NLCDs"].type() == BSON_TYPE_ARRAY && "NLCDs format error");
    assert(record["NLCDs"].count() == N_tag && "NLCDs should have `N_tag` integers");
    vector<int> NLCDs; NLCDs.resize(N_tag);
    printf("NLCDs:");
    for (int i=0; i<N_tag; ++i) {
        assert(record["NLCDs"][i].existed() && record["NLCDs"][i].type() == BSON_TYPE_INT32 && "each NLCD should be an integer");
        int NLCD = record["NLCDs"][i].value<int32_t>();
        assert(NLCD > 0 && NLCD <= TAG_L4XX_SAMPLE_BYTE && "invalid NLCD");
        NLCDs[i] = NLCD;
        printf(" %d", NLCD);
    } printf("\n");

    // sequences
    assert(record["sequences"].existed() && record["sequences"].type() == BSON_TYPE_ARRAY && "sequences format error");
    assert(record["sequences"].count() == N_tag && "sequences should match `N_tag`");
    vector< vector<Tag_Sample_t> > sequences; sequences.resize(N_tag);
    size_t max_seq_length = 0;
    for (int i=0; i<N_tag; ++i) {
        BsonOp arr = record["sequences"][i];
        assert(arr.existed() && arr.type() == BSON_TYPE_ARRAY && "each sequence should be a vector");
        vector<string> compressed; int arr_length = arr.count();
        for (int j=0; j<arr_length; ++j) {
            compressed.push_back(arr[j].value<string>());
		    printf("%s\n", compressed.back().c_str());
        }
        sequences[i] = FastDSM_Encoder::uncompressed_vector(compressed);
        if (sequences[i].size() > max_seq_length) max_seq_length = sequences[i].size();
    } printf("max_seq_length: %llu (%f ms)\n", max_seq_length, max_seq_length / frequency * 1000);

    size_t target_seq_length = max_seq_length;  // final result will not be less than this
    if (EQUAL_LEN) {
        assert(record["data_id"].existed() && record["data_id"].type() == BSON_TYPE_UTF8);
        string data_id_str = record["data_id"].value<string>();
        assert(MongoDat::isPossibleOID(data_id_str.c_str()) && "data_id invalid");
        bson_oid_t data_id = MongoDat::parseOID(data_id_str.c_str());
        vector<char> data_binary = mongodat.get_binary_file(data_id);
        size_t data_id_seq_length = (data_binary.size() / sizeof(complex<float>) / 80000.f) * frequency + 1;
        if (data_id_seq_length > target_seq_length) target_seq_length = data_id_seq_length;
        // to ensure that output sequence will be no less than data_id ones
    } printf("target_seq_length: %llu (%f ms)\n", target_seq_length, target_seq_length / frequency * 1000);
    // then push back 0 to make all the sequences to target_seq_length
    for (int i=0; i<N_tag; ++i) {
        sequences[i].resize(target_seq_length);
    }

    // fov angle
    assert(record["fov"].existed() && record["fov"].type() == BSON_TYPE_DOUBLE && "fov format error");
    double fov = record["fov"].value<double>();

    // const_dist
    assert(record["const_dist"].existed() && record["const_dist"].type() == BSON_TYPE_DOUBLE 
        && "const_dist format error");
    const_dist = record["const_dist"].value<double>();

    // tag location
    assert(record["tag_location"].existed() && record["tag_location"].type() == BSON_TYPE_ARRAY
        && "tag_location format error");
    BsonOp btag_location = record["tag_location"];
    vector< vector< Point > > locations;    // locations[N_tag][S_location]
    locations.resize(N_tag);
    for (int i=0; i<N_tag; ++i) {
        assert(btag_location[i].existed() && btag_location[i].type() == BSON_TYPE_ARRAY 
            && "btag_location format error");
        BsonOp btag_locationj = btag_location[i];
        locations[i].resize(S_location);
        for (int j=0; j<S_location; ++j) {
            assert(btag_locationj[j].existed() && btag_locationj[j].type() == BSON_TYPE_ARRAY 
                && btag_locationj[j].count() == 3 && "should be a three-element tuple(x,y,z)");
            assert(btag_locationj[j][0].type() == BSON_TYPE_DOUBLE && btag_locationj[j][1].type() == BSON_TYPE_DOUBLE 
                && "should be double (x,y,z) coordinate");
            locations[i][j].x = btag_locationj[j][0].value<double>();
            locations[i][j].y = btag_locationj[j][1].value<double>();
            locations[i][j].z = btag_locationj[j][2].value<double>();
        }
    }

    // tag change time
    assert(record["tag_change_time"].existed() && record["tag_change_time"].type() == BSON_TYPE_ARRAY
        && "tag_change_time format error");
    assert(record["tag_change_time"].count() == S_location && "tag_change_time should match `S_location`");
    vector< int32_t > tag_change_time;
    tag_change_time.resize(S_location);
    for(int i=0; i<S_location; ++i){
        tag_change_time[i] = record["tag_change_time"][i].value<int32_t>();
    }

    // noise
    double noise = 0;
    if (record["noise"].existed() && record["noise"].type() == BSON_TYPE_DOUBLE) {
        noise = record["noise"].value<double>();
    } printf("noise: %f\n", noise);

    
    // // emulate
    // vector< vector< complex<float> > > emulateds; emulateds.resize(M_reader);
    // // for each reader, initialize emulators
    // for (int i=0; i<M_reader; ++i) {
    //     vector<MS_Emulator_NLCDs> emulators;
    //     for (int j=0; j<N_tag; ++j) emulators.push_back(MS_Emulator_NLCDs(NLCDs[j], csi[j][i]));
    //     for (size_t k=0; k<target_seq_length; ++k) {
    //         vector< complex<double> > seg = MS_Emulator_Single::create_segment();
    //         for (int j=0; j<N_tag; ++j) emulators[j].emulate_acc(seg, sequences[j][k]);
    //         // convert from complex<float> to complex<double>
    //         for (auto it = seg.begin(); it != seg.end(); ++it) emulateds[i].push_back((complex<float>)*it);
    //     }
    // }

    // emulate four signals: two polarization directions, quadrature demodulation sin and cos
    vector< vector< complex<float> > > emulated_sin, emulated_cos;
    emulated_sin.resize(M_reader);  emulated_cos.resize(M_reader);
    for(int i=0; i<M_reader; ++i){
        int loc_idx = 0;
        vector< vector<MS_Emulator_NLCDs> > emulators;
        emulators.resize(2);
        for(size_t k = 0; k<target_seq_length; ++k){
            if(loc_idx < S_location && k == tag_change_time[loc_idx]){
                // printf("tag change location %d, symbol index %lld\n", loc_idx, k);
                emulators[0].clear();
                emulators[1].clear();
                for(int j=0; j<N_tag; ++j) {
                    Point pt = locations[j][loc_idx];
                    double amp_sin = get_amp(pt, fov) * get_sin(pt);
                    double amp_cos = get_amp(pt, fov) * get_cos(pt);
                    emulators[0].push_back(MS_Emulator_NLCDs(NLCDs[j], amp_sin));
                    emulators[1].push_back(MS_Emulator_NLCDs(NLCDs[j], amp_cos));
                    printf("tag %d amp_sin=%lf, amp_cos=%lf\n", j, amp_sin, amp_cos);
                }
                loc_idx++;
            }

            vector< complex<double> > seg_sin = MS_Emulator_Single::create_segment();
            vector< complex<double> > seg_cos = MS_Emulator_Single::create_segment();
            for(int j=0; j<N_tag; ++j){
                emulators[0][j].emulate_acc(seg_sin, sequences[j][k]);
                emulators[1][j].emulate_acc(seg_cos, sequences[j][k]);
            }
            
            // convert from complex<float> to complex<double>; why should we do this?
            for (auto it = seg_sin.begin(); it != seg_sin.end(); ++it) {
                emulated_sin[i].push_back((complex<float>)*it);
            }
            for (auto it = seg_cos.begin(); it != seg_cos.end(); ++it){
                emulated_cos[i].push_back((complex<float>)*it);
            }
        }
        // printf("finish emulation of reader %d\n", i);
    }
    // printf("emulated_sin[0] size = %d\n", emulated_sin[0].size());

    // put them into database
    vector<string> emulated_ids;
    for (int i=0; i<M_reader; ++i) {
        mongodat.upload_record("emulated_sin", (float*)emulated_sin[i].data(), 2, emulated_sin[i].size(), NULL, "emulated_sin", 1/80., "time(ms)", 1, "I,Q");
        printf("upload emulated_sin file for reader [%d] with ID: %s\n", i, MongoDat::OID2str(mongodat.get_fileID()).c_str());
        emulated_ids.push_back(MongoDat::OID2str(mongodat.get_fileID()));

        mongodat.upload_record("emulated_cos", (float*)emulated_cos[i].data(), 2, emulated_cos[i].size(), NULL, "emulated_cos", 1/80., "time(ms)", 1, "I,Q");
        printf("upload emulated_cos file for reader [%d] with ID: %s\n", i, MongoDat::OID2str(mongodat.get_fileID()).c_str());
        emulated_ids.push_back(MongoDat::OID2str(mongodat.get_fileID()));

    }
    record["emulated_ids"].remove();
	record["emulated_ids"].build_array();
    record["emulated_ids"].append(emulated_ids);

    record.save();

    mongodat.close();

    return 0;
}
