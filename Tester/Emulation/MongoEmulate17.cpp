// use static here, simply test it and used later with demodulator
#define STATIC_EMULATOR_FOR_EASIER_COPY
#include "emulator_mseq.h"
#define MONGODAT_IMPLEMENTATION
#include "mongodat.h"
#include "sysutil.h"
#include <regex>
#include <random>
using namespace std;

const char *MONGO_URL, *MONGO_DATABASE;
MongoDat mongodat;
FastDSM_Encoder encoder;

int main(int argc, char** argv) {
	HANDLE_DATA_BASIC_ARG_MODIFY_ARGC_ARGV(argc, argv, &MONGO_URL, &MONGO_DATABASE);

	MongoDat::LibInit();
	mongodat.open(MONGO_URL, MONGO_DATABASE);

    if (argc != 3 && argc != 4) {
        printf("usage: <collection> <id(12 byte hex = 24 char)> [EQUAL_LEN:0]\n");
        printf("  if EQUAL_LEN is applied, then the output data will be no less than that. this is useful when comparing with real-world data\n");
        printf("\n");
        printf("the database document should have the following fields:\n");
        printf("  refs_file: filename, e.g. ref17mseq8kSs.9v.bin or ref17mseq8kSs.5.5v.bin\n");
        printf("             you can download them from https://github.com/wuyuepku/RetroTurbo/releases/tag/LCDmodel\n");
        printf("             use `ref17mseq8kSs.9v.bin` or `ref17mseq8kSs.5.5v.bin`\n");
        printf("  csi: channel state information, given N tag and M reader, the full signal strength from i-th tag to j-th reader\n");
        printf("             each value is a complex number (stored as a vector of two double value)\n");
        printf("  frequency: frequency of the tag sequences, which should be a factor of 80000\n");
        printf("  NLCDs: array of N integers, each is the NLCD of a tag\n");
        printf("  sequences: N sequence of modulated data (possibly generated by FastDSM_Modulate)\n");
        printf("  noise: [optional] given by standard deviation, Guassian distribution\n");
        printf("the results will be stored in a vector `emulated_ids`, in which each string refers to a data that could be plotted in WebGUI\n");
        printf("\n");
        return -1;
    }

	const char* collection_str = argv[1];
	const char* record_id_str = argv[2];
	BsonOp record = mongodat.get_bsonop(collection_str, record_id_str);
    bool EQUAL_LEN = argc > 3 ? atoi(argv[3]) : 0;

	printf("reading parameters from database record [%s:%s]\n", collection_str, record_id_str);
    
    // frequency
    assert(record["frequency"].existed() && record["frequency"].type() == BSON_TYPE_DOUBLE);
    double frequency = record["frequency"].value<double>(); printf("frequency: %f\n", frequency);
    
    // read reference file
    assert(record["refs_file"].existed() && record["refs_file"].type() == BSON_TYPE_UTF8);
    string refs_file = record["refs_file"].value<string>(); printf("refs_file: %s\n", refs_file.c_str());
    ifstream file(refs_file.c_str(), std::ios::binary);
    assert(file && "reference file not exists");
    file.unsetf(std::ios::skipws);  // Stop eating new lines in binary mode!!!
    file.seekg(0, std::ios::end);
    streampos fileSize = file.tellg();
    assert(fileSize == (1 << 17) * 40 * sizeof(complex<float>) && "file size error");
    file.seekg(0, std::ios::beg);
    vector< complex<float> > vec; vec.resize((1 << 17) * 40);
    file.read((char*)vec.data(), fileSize);
    MS_Emulator_Single::set_ref(17, 2000, 80000, frequency, vec);

    // read channel state information
    assert(record["csi"].existed() && record["csi"].type() == BSON_TYPE_ARRAY && "csi format error");
    BsonOp bcsi = record["csi"];
    vector< vector< complex<double> > > csi;  // csi[N_tag][M_reader]
    int N_tag = bcsi.count();
    assert(N_tag > 0 && "should be at least one tag");
    csi.resize(N_tag);
    for (int i=0; i<N_tag; ++i) {
        assert(bcsi[i].existed() && bcsi[i].type() == BSON_TYPE_ARRAY && "csi format error");
        BsonOp bcsij = bcsi[i];
        int M_reader = bcsij.count();
        csi[i].resize(M_reader);
        for (int j=0; j<M_reader; ++j) {
            assert(bcsij[j].existed() && bcsij[j].type() == BSON_TYPE_ARRAY && bcsij[j].count() == 2 && "should be a complex number in vector [real, imag]");
            assert(bcsij[j][0].type() == BSON_TYPE_DOUBLE && bcsij[j][1].type() == BSON_TYPE_DOUBLE && "should be complex double");
            csi[i][j].real(bcsij[j][0].value<double>());
            csi[i][j].imag(bcsij[j][1].value<double>());
        }
    }
    // check consistency in M_reader
    int M_reader = csi[0].size();
    assert(M_reader > 0 && "should be at least one reader");
    for (int i=0; i<N_tag; ++i) assert(M_reader == (int)csi[i].size() && "M_reader should be consistent");
    // print out the csi matrix
    printf("CSI matrix: N_tag * M_reader = %d * %d\n", N_tag, M_reader);
    for (int i=0; i<N_tag; ++i) {
#define CSI_SINGLE_WIDTH 30
#define CSI_SINGLE_FORMAT "%.5e + %.5e j"
        for (int k=(CSI_SINGLE_WIDTH+2) * M_reader + 1; k>0; --k) { printf("-"); } printf("\n");
        for (int j=0; j<M_reader; ++j) {
            char buf[256];
            sprintf(buf, CSI_SINGLE_FORMAT, csi[i][j].real(), csi[i][j].imag());
            int len = strlen(buf);
            assert(len <= CSI_SINGLE_WIDTH && "set `CSI_SINGLE_WIDTH` to a larger one to display CSI matrix properly");
            printf("|"); for (int k=0; k<CSI_SINGLE_WIDTH-len; ++k) printf(" ");
            printf("%s ", buf);
        } printf("|\n");
    } for (int k=(CSI_SINGLE_WIDTH+2) * M_reader + 1; k>0; --k) { printf("-"); } printf("\n");

    // NLCDs
    assert(record["NLCDs"].existed() && record["NLCDs"].type() == BSON_TYPE_ARRAY && "NLCDs format error");
    assert(record["NLCDs"].count() == N_tag && "NLCDs should have `N_tag` integers");
    vector<int> NLCDs; NLCDs.resize(N_tag);
    printf("NLCDs:");
    for (int i=0; i<N_tag; ++i) {
        assert(record["NLCDs"][i].existed() && record["NLCDs"][i].type() == BSON_TYPE_INT32 && "each NLCD should be an integer");
        int NLCD = record["NLCDs"][i].value<int32_t>();
        assert(NLCD > 0 && NLCD <= TAG_L4XX_SAMPLE_BYTE && "invalid NLCD");
        NLCDs[i] = NLCD;
        printf(" %d", NLCD);
    } printf("\n");

    // sequences
    assert(record["sequences"].existed() && record["sequences"].type() == BSON_TYPE_ARRAY && "sequences format error");
    assert(record["sequences"].count() == N_tag && "sequences should match `N_tag`");
    vector< vector<Tag_Sample_t> > sequences; sequences.resize(N_tag);
    size_t max_seq_length = 0;
    for (int i=0; i<N_tag; ++i) {
        BsonOp arr = record["sequences"][i];
        assert(arr.existed() && arr.type() == BSON_TYPE_ARRAY && "each sequence should be a vector");
        vector<string> compressed; int arr_length = arr.count();
        for (int j=0; j<arr_length; ++j) {
            compressed.push_back(arr[j].value<string>());
		    printf("%s\n", compressed.back().c_str());
        }
        sequences[i] = FastDSM_Encoder::uncompressed_vector(compressed);
        if (sequences[i].size() > max_seq_length) max_seq_length = sequences[i].size();
    } printf("max_seq_length: %llu (%f ms)\n", max_seq_length, max_seq_length / frequency * 1000);

    size_t target_seq_length = max_seq_length;  // final result will not be less than this
    if (EQUAL_LEN) {
        assert(record["data_id"].existed() && record["data_id"].type() == BSON_TYPE_UTF8);
        string data_id_str = record["data_id"].value<string>();
        assert(MongoDat::isPossibleOID(data_id_str.c_str()) && "data_id invalid");
        bson_oid_t data_id = MongoDat::parseOID(data_id_str.c_str());
        vector<char> data_binary = mongodat.get_binary_file(data_id);
        size_t data_id_seq_length = (data_binary.size() / sizeof(complex<float>) / 80000.f) * frequency + 1;
        if (data_id_seq_length > target_seq_length) target_seq_length = data_id_seq_length;
        // to ensure that output sequence will be no less than data_id ones
    } printf("target_seq_length: %llu (%f ms)\n", target_seq_length, target_seq_length / frequency * 1000);
    // then push back 0 to make all the sequences to target_seq_length
    for (int i=0; i<N_tag; ++i) {
        sequences[i].resize(target_seq_length);
    }

    // noise
    double noise = 0;
    if (record["noise"].existed() && record["noise"].type() == BSON_TYPE_DOUBLE) {
        noise = record["noise"].value<double>();
    } printf("noise: %f\n", noise);

    // emulate
    vector< vector< complex<float> > > emulateds; emulateds.resize(M_reader);
    // for each reader, initialize emulators
    for (int i=0; i<M_reader; ++i) {
        vector<MS_Emulator_NLCDs> emulators;
        for (int j=0; j<N_tag; ++j) emulators.push_back(MS_Emulator_NLCDs(NLCDs[j], csi[j][i]));
        for (size_t k=0; k<target_seq_length; ++k) {
            vector< complex<double> > seg = MS_Emulator_Single::create_segment();
            for (int j=0; j<N_tag; ++j) emulators[j].emulate_acc(seg, sequences[j][k]);
            // convert from complex<float> to complex<double>
            for (auto it = seg.begin(); it != seg.end(); ++it) emulateds[i].push_back((complex<float>)*it);
        }
    }

    // put them into database
    vector<string> emulated_ids;
    for (int i=0; i<M_reader; ++i) {
        mongodat.upload_record("emulated", (float*)emulateds[i].data(), 2, emulateds[i].size(), NULL, "emulated", 1/80., "time(ms)", 1, "I,Q");
        printf("upload emulated file for reader [%d] with ID: %s\n", i, MongoDat::OID2str(mongodat.get_fileID()).c_str());
        emulated_ids.push_back(MongoDat::OID2str(mongodat.get_fileID()));
    }
    record["emulated_ids"].remove();
	record["emulated_ids"].build_array();
    record["emulated_ids"].append(emulated_ids);

    record.save();

    mongodat.close();

    return 0;
}
