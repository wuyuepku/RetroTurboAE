/*
 * This file is to recover repeated data by average them
 */

#define MONGODAT_IMPLEMENTATION
#include "mongodat.h"
#include "sysutil.h"
#include "modulator.h"
using namespace std;

const char *MONGO_URL, *MONGO_DATABASE;
MongoDat mongodat;

int main(int argc, char** argv) {
	HANDLE_DATA_BASIC_ARG_MODIFY_ARGC_ARGV(argc, argv, &MONGO_URL, &MONGO_DATABASE);

	MongoDat::LibInit();
	mongodat.open(MONGO_URL, MONGO_DATABASE);

	if (argc < 4 || argc > 6) {
		printf("usage: <collection> <id(12 byte hex = 24 char)> <bias(int)> [data_id_key] [sequence_key=\"base_sequence\"]\n");
        printf("*** with positive bias, the curve is moving left ***\n\n");
        printf("the document should have the following values:\n");
        printf("  frequency: LCD Tx frequency\n");
        printf("  o_final_preamble_length: the sample count of preamble, could be generated by \"General_Repeat_Record_Gen.cpp\"\n");
        printf("  base_sequence: a list of string that contains the basic sequence wanna collect\n");
        printf("  repeat_cnt: repeat the base_sequence for several times\n\n");
        printf("[warning] it doesn't ensure the time alignment when the packet is too long, because the existance of clock error\n");
		return -1;
	}

	const char* collection_str = argv[1];
	const char* record_id_str = argv[2];
    int bias = atoi(argv[3]);  // TODO +-
    const char* data_id_key_str = "data_id";
    if (argc >= 5) data_id_key_str = argv[4];
    const char* base_sequence_key = "base_sequence";
    if (argc >= 6) base_sequence_key = argv[5];
	BsonOp record = mongodat.get_bsonop(collection_str, record_id_str);
    
    string output_data_id_key = data_id_key_str;
    output_data_id_key = "o_" + output_data_id_key;
    
	printf("reading parameters from database record [%s:%s]\n", collection_str, record_id_str);

    // frequency
    assert(record["frequency"].existed() && record["frequency"].type() == BSON_TYPE_DOUBLE);
    double frequency = record["frequency"].value<double>(); printf("frequency: %f\n", frequency);

    // repeat_cnt
    assert(record["repeat_cnt"].existed() && record["repeat_cnt"].type() == BSON_TYPE_INT32);
    int repeat_cnt = record["repeat_cnt"].value<int32_t>(); printf("repeat_cnt: %d\n", repeat_cnt);
    assert(repeat_cnt > 0 && repeat_cnt <= 10000 && "should it exceed 10000? modify code if REALLY necessary");

    // base_sequence
    assert(record[base_sequence_key].existed() && record[base_sequence_key].type() == BSON_TYPE_ARRAY);
    int str_cnt = record[base_sequence_key].count(); printf("base_sequence string count: %d\n", str_cnt);
    assert(str_cnt > 0 && "cannot send empty base_sequence");
    vector<string> base_sequence; base_sequence.resize(str_cnt);
    printf("base_sequence:\n");
    for (int i=0; i<str_cnt; ++i) {
        base_sequence[i] = record[base_sequence_key][i].value<string>();
        printf("    %s\n", base_sequence[i].c_str());
    }
    int data_length = FastDSM_Encoder::uncompressed_vector(base_sequence).size();
    int output_length = data_length * 80000 / frequency;
    printf("data_length: %d, output_length: %d\n", data_length, output_length);

    // o_final_preamble_length
    assert(record["o_final_preamble_length"].existed() && record["o_final_preamble_length"].type() == BSON_TYPE_INT32);
    int o_final_preamble_length = record["o_final_preamble_length"].value<int32_t>(); printf("o_final_preamble_length: %d\n", o_final_preamble_length);

    int start = o_final_preamble_length * 80000 / frequency + bias;
    printf("start: %d (%f ms)\n", start, start/80.);
    
	assert(record[data_id_key_str].existed() && record[data_id_key_str].type() == BSON_TYPE_UTF8 && "data_id needed");
	string binary_id_str = record[data_id_key_str].value<string>();
	assert(MongoDat::isPossibleOID(binary_id_str.c_str()) && "data_id invalid");
	bson_oid_t record_id = MongoDat::parseOID(binary_id_str.c_str());
	vector<char> binary = mongodat.get_binary_file(record_id);
    assert(binary.size() > 0 && binary.size() % sizeof(complex<float>) == 0 && "binary alignment error");
    const complex<float>* data = (const complex<float>*)binary.data();
    int length = binary.size() / sizeof(complex<float>);

    vector< complex<float> > o_data; o_data.resize(output_length);
    for (int i=0; i<repeat_cnt; ++i) {
        assert(start+(i+1)*output_length <= length && "data is not long enough");
        int bidx = start + i*output_length;
        for (int j=0; j<output_length; ++j) {
            o_data[j] += data[bidx+j];
        }
    }
    for (int j=0; j<output_length; ++j) o_data[j] /= repeat_cnt;

	mongodat.upload_record("o_data", (float*)o_data.data(), 2, o_data.size(), NULL, "o_data", 1/80., "time(ms)", 1, "I,Q");
	printf("upload o_data with ID: %s\n", MongoDat::OID2str(mongodat.get_fileID()).c_str());

    record[output_data_id_key.c_str()] = MongoDat::OID2str(mongodat.get_fileID());
    record.save();

    mongodat.close();

    return 0;
}
